<?php

// $Id$ 

/**
 * 
 * @file
 * Taxonomy Manager
 * 
 * Administration interface for managing taxonomy vocabularies
 * 
 */


/**
 * Implementation of hook_menu
 */
function taxonomy_manager_menu($may_cache) {
  $items = array();
  
  if ($may_cache) {
    $items[] = array('path' => 'admin/content/taxonomy_manager',
      'title' => t('Taxonomy Manager'),
      'description' => t('Administer vocabularies with the Taxonomy Manager'),
      'callback' => 'taxonomy_manager_voc_list',
      'access' => user_access('administer taxonomy'),
      'type' => MENU_NORMAL_ITEM
    );
  }
  
  if (arg(0) == 'admin' && arg(1) == 'content' && arg(2) == 'taxonomy_manager' && is_numeric(arg(3))) {
    $vid = arg(3);
    $items[] = array('path' => 'admin/content/taxonomy_manager/'. $vid,
      'title' => t('Taxonomy Manager'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('taxonomy_manager_form', $vid),
      'access' => user_access('administer taxonomy'), 
      'type' => MENU_CALLBACK 
    );
  } 
  
  return $items;
}

/**
 * list of vocabularies, which link to Taxonomy Manager interface
 */
function taxonomy_manager_voc_list() {
  $vocabularies = taxonomy_get_vocabularies();
  $voc_list = array();
  
  foreach ($vocabularies as $vocabulary) {
    $voc_list[] = l($vocabulary->name, 'admin/content/taxonomy_manager/'. $vocabulary->vid);
  }
  
  return theme('item_list', $voc_list, "Vocabularies:");
  
}

/**
 * defines forms for taxonomy manager interface
 */
function taxonomy_manager_form($vid) {
  $module_path = drupal_get_path('module', 'taxonomy_manager') .'/';
  drupal_add_css($module_path .'css/taxonomy_manager.css');
  drupal_add_js($module_path .'js/tree.js');
  drupal_add_js($module_path .'js/hideForm.js');
  
  $form = array();
  
  $voc = taxonomy_get_vocabulary($vid);
  
  if (!is_numeric($voc->vid)) {
    $text = t('No vocabulary with this ID available!. ');
    $text .= t('Check this !link_list for available vocabularies or !link_create a new one', array('!link_list' => l('list', 'admin/content/taxonomy_manager'), '!link_create' => l('create', 'admin/content/taxonomy/add/vocabulary')));
    $form['text'] = array( 
      '#value' => $text,
    );
    return $form;
  }
  
  $form['vid'] = array('#type' => 'value', "#value" => $vid);

  $tree = taxonomy_get_tree($vid);
  
  if (count($tree) == 0) {
    $text = t('No terms available');
    $form['text'] = array( 
      '#value' => $text,
    );
    $form += taxonomy_manager_add_form(false);
    return $form;
  }
  
  $form['taxonomytree'] = array( 
    '#type' => 'fieldset',
    '#title' => $voc->name,
    '#theme' => 'taxonomy_manager_elements',
    '#tree' => TRUE,
    '#weight' => 10,
    '#prefix' => '<div id="taxonomytree">',
    '#suffix' => '</div>',
  );
  
  $form['taxonomytree'] += taxonomy_manager_build_tree_form($index = 0, $tree);
  drupal_add_js(array('taxonomytree' => array('id' => 'taxonomytree')), 'setting');
  
  $form['toolbar'] = array( 
    '#type' => 'fieldset', 
    '#title' => t('Toolbar'),
    '#weight' => -10, 
  );
  
  $form['toolbar']['delete_confirm'] = array( 
    '#type' => 'button', 
    '#value' => t('Delete selected'),
    '#theme' => 'no_submit_button', 
  );
  
  $form['toolbar']['weight'] = array( 
    '#type' => 'submit',
    '#value' => t('Update weights'),
  );
  
  $form['toolbar']['add_show'] = array( 
    '#type' => 'button', 
    '#value' => t('Add terms'),
    '#theme' => 'no_submit_button',  
  );
  
  $form['toolbar']['merge_show'] = array( 
    '#type' => 'button', 
    '#value' => t('Merge selected into...'), 
    '#theme' => 'no_submit_button', 
  );
  
  $form['toolbar']['move_show'] = array( 
    '#type' => 'button', 
    '#value' => t('Move selected to...'),
    '#theme' => 'no_submit_button', 
  );
  
  $form += taxonomy_manager_add_form();
  
  $form += taxonomy_manager_merge_form($voc);
  
  $form += taxonomy_manager_move_form($voc);
  
  $form += taxonomy_manager_confirm_delete($voc);

  return $form;
}

/**
 * confirmation form for deleting selected terms
 */
function taxonomy_manager_confirm_delete($voc) {
  drupal_add_js(array('hideForm' => array(
    'show_button' => 'edit-delete-confirm', 
    'hide_button' => 'edit-delete-cancel', 
    'div' => 'del-confirm-form')), 'setting');
  
  $text = t('Confirmation required! Remember all term specific data will be lost!');
  
  $form = array();
  
  $form['delete'] = array(
    '#type' => 'fieldset',
    '#tree' => TRUE,
    '#title' => t('Confirmation'),
    '#prefix' => '<div id="del-confirm-form">',
    '#suffix' => '</div>',
  );
  
  $form['delete']['text'] = array( 
    '#value' => "<b>". $text ."</b>", 
  );
  
  if ($voc->hierarchy != 0) {
    $options = array( 
      'delete_orphans' => t('Delete orphans'), 
    );
     
    $form['delete']['options'] = array( 
      '#type' => 'checkboxes', 
      '#title' => t('Options'), 
      '#options' => $options, 
    );
  }
  
  $form['delete']['delete'] = array( 
    '#type' => 'submit', 
    '#value' => t('Delete'), 
  );
  
  $form['delete']['cancel'] = array(
    '#type' => 'button', 
    '#value' => t('Cancel'), 
    '#theme' => 'no_submit_button',  
  );
  
  return $form;
}

/**
 * form for adding multiple terms
 */
function taxonomy_manager_add_form($hide_form = TRUE) {
  if ($hide_form) {
    drupal_add_js(array('hideForm' => array(
      'show_button' => 'edit-add-show', 
      'hide_button' => 'edit-add-cancel', 
      'div' => 'add-form')), 'setting');
  }
  
  $form = array();
  
  $form['add'] = array( 
    '#type' => 'fieldset', 
    '#tree' => TRUE,
    '#title' => t('Add new terms'),
    '#prefix' => '<div id="add-form">',
    '#suffix' => '</div>',
    '#description' => t('Depending on the hierarchy settings, you can set parents (one ore more).
                         Selected terms will get the parents of the new inserted'), 
  );
  
  for ($i=0; $i<5; $i++) {
    $form['add']['term'][$i] = array( 
      '#type' => 'textfield', 
    );
  }
  $form['add']['add'] = array( 
    '#type' => 'submit', 
    '#value' => t('Add'), 
  );
  
  $form['add']['cancel'] = array( 
    '#type' => 'button', 
    '#value' => t('Cancel'),
    '#theme' => 'no_submit_button',  
  );

  return $form;
  
}

/**
 * form for merging terms
 */
function taxonomy_manager_merge_form($voc) {
  drupal_add_js(array('hideForm' => array(
    'show_button' => 'edit-merge-show', 
    'hide_button' => 'edit-merge-cancel', 
    'div' => 'merge-form')), 'setting');
  
  $form = array();
  
  $form['merge'] = array( 
    '#type' => 'fieldset',
    '#tree' => TRUE,
    '#title' => t('Merging of terms'), 
    '#prefix' => '<div id="merge-form">',
    '#suffix' => '</div>', 
  );
  
  $help = t("You can choose either an exisiting term or either typ in a new
    term, which will be created automatically, as main term (selected terms
    get merged into this term)");
  
  $form['merge']['main_term'] = array(
    '#type' => 'textfield',
    '#title' => t('Main term'),
    '#description' => $help,
    '#required' => FALSE,
    '#autocomplete_path' => 'taxonomy/autocomplete/'. $voc->vid,
  );
  
  $options = array();
  
  switch ($voc->hierarchy) {
    //multiple hierarchy 
    case 2:  
      $options['collect_parents'] = t('Collect all parents of merging terms an add it to main term');
    
    //single hierarchy 
    case 1:  
      $options['collect_children'] = t('Collect all children of merging terms an add it to main term');
    break;
  }
  
  if ($voc->relations) {
    $options['collect_relations'] = t('Collect all relations of merging terms and add it to main term');
  }
  
  if (count($options) > 0) {
    $form['merge']['options'] = array( 
      '#type' => 'checkboxes', 
      '#title' => t('Options'), 
      '#options' => $options, 
    );
  }
   
  $form['merge']['submit'] = array( 
    '#type' => 'submit', 
    '#value' => t('Merge'), 
  );
   
  $form['merge']['cancel'] = array( 
    '#type' => 'button', 
    '#value' => t('Cancel'), 
    '#theme' => 'no_submit_button', 
  );
  
  return $form;
}

/**
 * form for moving terms in hierarchies
 */
function taxonomy_manager_move_form($voc) {
  drupal_add_js(array('hideForm' => array(
    'show_button' => 'edit-move-show', 
    'hide_button' => 'edit-move-cancel',
    'div' => 'move-form')), 'setting');
  
  $form = array();
  
  $form['move'] = array( 
    '#type' => 'fieldset',
    '#tree' => TRUE,
    '#title' => t('Moving of terms'),
    '#prefix' => '<div id="move-form">',
    '#suffix' => '</div>',
  );
  
  $help = t("You can choose either an exisiting term or either typ in a new
    term, which will be created automatically, as parent term (selected terms
    get children of this term). If multiple parents are allowed, you can seperate
    more terms in the autocomplete form with ','.
    If selected terms should have no parent, leave it blank!");
  
  $form['move']['parents'] = array(
    '#type' => 'textfield',
    '#title' => t('Parent term(s)'),
    '#description' => $help,
    '#required' => FALSE,
    '#autocomplete_path' => 'taxonomy/autocomplete/'. $voc->vid,
  );
  
  $options = array();
  
  if ($voc->hierarchy == 2) {
    $options['keep_old_parents'] = t('Don\'t delete old parents, only add new parents (multiple parents)');
  }
  
  if (count($options) > 0) {
    $form['move']['options'] = array( 
      '#type' => 'checkboxes', 
      '#title' => t('Options'), 
      '#options' => $options, 
    );
  }
  
  $form['move']['submit'] = array( 
    '#type' => 'submit', 
    '#value' => t('Move'),
    '#attributes' => array('id' => 'move-button'), 
  );
   
  $form['move']['cancel'] = array( 
    '#type' => 'button', 
    '#value' => t('Cancel'),
    '#theme' => 'no_submit_button',  
  );
  
  return $form;
}

/**
 * recursive function for building nested form array 
 * with checkboxes and weight forms for each term
 * 
 * nested form array are allways appended to parent-form['children'] 
 *
 * @param $index current index in tree, start with 0
 * @param $tree of terms (generated by taxonomy_get_tree)
 * @return a form array 
 */
function taxonomy_manager_build_tree_form(&$index, $tree) {
  $form = array();
  $current_depth = $tree[$index]->depth;
  while ($index < count($tree) && $tree[$index]->depth >= $current_depth) {
    $term = $tree[$index];
    $form[$term->tid]['#attributes'] = array('id' => $term->tid);
    $form[$term->tid]['checkbox'] = array('#type' => 'checkbox', '#title' => $term->name);
    $form[$term->tid]['weight'] = array('#type' => 'weight', '#default_value' => array($term->weight));
    //store old values in form array, so that only changed weight values (new != old) are updated
    $form[$term->tid]['weight_old'] = array('#type' => 'value', '#value' => $term->weight);
    
    $index++;
    
    if ($tree[$index]->depth > $current_depth) {
      $form[$term->tid]['children'] = taxonomy_manager_build_tree_form($index, $tree);
    }
  }
  return $form;
}

/**
 * validates the form
 */
function taxonomy_manager_form_validate($form_id, $form_values) {
  $selected_tids = taxonomy_manager_get_selected_tids($form_values['taxonomytree']);
  
  switch ($form_values['op']) {
    case t('Delete'): 
      if (count($selected_tids) < 1) {
        form_set_error('delete', t("No terms selected"));
      }
      
      break;
      
    case t('Add'): 
      //check for parents concerning voc settings
      $voc = taxonomy_get_vocabulary($form_values['vid']);
      
      if ($voc->hierarchy == 0 && count($selected_tids) > 0) {
        form_set_error('add', t('This vocabulary doesn\'t provide hierarchies. Please unselect terms in the list before adding new terms.'));
      }
      else if ($voc->hierarchy == 1 && count($selected_tids) > 1) {
        form_set_error('add', t('This vocabulary provides only single hirarchies. Please select only one term in the list (at maximum)'));
      }
      
      break;
    
    case t('Merge'): 
      $main_terms = array();
      $main_terms = taxonomy_manager_autocomplete_tags_get_tids($form_values['merge']['main_term'], $form_values['vid']);
      if (count($main_terms) > 1) {
        form_set_error('merge][main_term', t("The field %title doesn't allows multiple values", array('%title' => "'". t('Main term') ."'")));
      }
      if (!is_numeric($main_terms[0]) || $main_terms[0] == 0) {
        form_set_error('merge][main_term', t("Error reading input from %title", array('%title' => "'". t('Main term') ."'")));
      }
      if (count($selected_tids) < 1) {
        form_set_error('merge', t("No terms for merging selected"));
      }
      break; 
    
    case t('Move'): 
      if (count($selected_tids) < 1) {
        form_set_error('move', t("No terms selected"));
      }
      break;
  }
}

/**
 * submits the taxonomy manager form
 */
function taxonomy_manager_form_submit($form_id, $form_values) { 
  $tids = array(); 
  $tids = taxonomy_manager_get_selected_tids($form_values['taxonomytree']);
  
  switch ($form_values['op']) {
    case t('Delete'):
      taxonomy_manager_delete_terms($tids, $form_values['delete']['options']);
      drupal_set_message("Selected terms deleted"); 
      break;
    
    case t('Update weights'):
      $weights = array();
      $weights = taxonomy_manager_get_updated_weights($form_values['taxonomytree']);       
      if (count($weights) > 0) {
        taxonomy_manager_update_weight($weights);
        drupal_set_message("Weights updated");
      }
      else {
        drupal_set_message("No weights changed");
      }
      break;
      
    case t('Add'): 
      foreach ($form_values['add']['term'] as $value) {
        if (!empty($value)) {
          $term = array();
          $term['name'] = $value;
          $term['vid'] = $form_values['vid'];
          $term['parent'] = $tids;
          taxonomy_save_term($term);
        }
      }
      drupal_set_message("Terms added");
      break;
      
    case t('Merge'):   
      $main_terms = taxonomy_manager_autocomplete_tags_get_tids($form_values['merge']['main_term'], $form_values['vid']);
      $main_term = $main_terms[0];
      taxonomy_manager_merge($main_term, $tids, $form_values['merge']['options']);
      drupal_set_message("Terms merged");
      break;
    
    case t('Move'): 
      $parents = taxonomy_manager_autocomplete_tags_get_tids($form_values['move']['parents'], $form_values['vid']);
      if (count($parents) == 0) $parents[0] = 0; //if empty, delete all parents
      taxonomy_manager_move($parents, $tids, $form_values['move']['options']);
      
      drupal_set_message("Terms moved");
      break;
      
  }
  
  drupal_goto('admin/content/taxonomy_manager/'. $form_values['vid']);
}

/**
 * returns term ids of selected checkboxes
 * 
 * goes through nested form array recursivly
 * 
 * @param $form_values
 * @return an array with term ids
 */
function taxonomy_manager_get_selected_tids($form_values) {
  $tids = array();
  if (is_array($form_values)) {
    foreach ($form_values as $tid => $form_value) {
      if ($form_value['checkbox']) {
        $tids[$tid] = $tid;
      }
      if (is_array($form_value['children'])) {
        $tids += taxonomy_manager_get_selected_tids($form_value['children']);
      }
    }
  }
  return $tids;
}

/**
 * looks for updated weights in list 
 * (compares old values to current select box value, so that only changed values 
 * have to be updated in the database)
 * 
 * goes through nested form array recursivly
 * 
 * @param $form_values
 * @return an array like Array($tid => $new_weight, ...)
 */
function taxonomy_manager_get_updated_weights($form_values) {
  $weights = array();
  if (is_array($form_values)) {
    foreach ($form_values as $tid => $form_value) {
      if ($form_value['weight'] != $form_value['weight_old']) {
        $weights[$tid] = $form_value['weight'];
      }
      if (is_array($form_value['children'])) {
        $weights += taxonomy_manager_get_updated_weights($form_value['children']);
      }
    }
  }
  return $weights;
}

/**
 * deletes terms from the database
 * optional orphans (terms where parent get deleted) can be deleted as well
 * 
 * (difference to taxonomy_del_term: deletion of orphans optional)
 *
 * @param $tids array of term id to delete
 * @param $options associative array with options
 *   if $options['delete_orphans'] is true, orphans get deleted
 */
function taxonomy_manager_delete_terms($tids, $options = array()) {
  if (!is_array($tids)) array($tids);
  while (count($tids) > 0) {
    $orphans = array();
    foreach ($tids as $tid) {      
      if ($children = taxonomy_get_children($tid)) {
        foreach ($children as $child) {
          $parents = taxonomy_get_parents($child->tid);
          if ($options['delete_orphans']) {
            if (count($parents) == 1) {
              $orphans[] = $child->tid;
            }
          }
          else {
            if (count($parents) == 1) {
              db_query("UPDATE {term_hierarchy} SET parent = 0 WHERE tid = %d AND parent = %d", $child->tid, $tid);
            }
            else {
              db_query("DELETE FROM {term_hierarchy} WHERE tid = %d AND parent = %d", $child->tid, $tid);
            }
          }
        }
      }
      
      db_query('DELETE FROM {term_data} WHERE tid = %d', $tid);
      db_query('DELETE FROM {term_hierarchy} WHERE tid = %d', $tid);
      db_query('DELETE FROM {term_relation} WHERE tid1 = %d OR tid2 = %d', $tid, $tid);
      db_query('DELETE FROM {term_synonym} WHERE tid = %d', $tid);
      db_query('DELETE FROM {term_node} WHERE tid = %d', $tid);
    
      $term = (array) taxonomy_get_term($tid);
      module_invoke_all('taxonomy', 'delete', 'term', $term);
      $tids = $orphans;
    }
  } 
}

/**
 * updates weights for terms
 *
 * @param $weights an array like Array($tid => $weight)
 */
function taxonomy_manager_update_weight($weights) {
  foreach ($weights as $tid => $weight) {
    db_query("UPDATE {term_data} SET weight = %d WHERE tid = %d", $weight, $tid);
  }
}

/**
 * moves terms in hierarchies to other parents
 *
 * @param $parents 
 *   array of parent term ids to where children can be moved
 *   array should only contain more parents if multi hiearchy enabled 
 *   if array contains 0, terms get placed to first (root) level
 * @param $children
 *   array of term ids to move
 * @param $options
 *   array of additional options for moving
 *   'keep_old_parents': if true, exisiting parents doesn't get deleted (only possible with multi hierarchies)
 */
function taxonomy_manager_move($parents, $children, $options = array()) {
  if (!is_array($parents)) array($parents);
  
  foreach ($children as $child) {
    if (!$options['keep_old_parents']) {
      db_query("DELETE FROM {term_hierarchy} WHERE tid = %d", $child);
    }
    foreach ($parents as $parent) {
      db_query("INSERT INTO {term_hierarchy} SET parent = %d, tid = %d", $parent, $child, $child);
    }
  }
}

/**
 * merges terms into another term (main term), all merged term get added
 * to the main term as synonyms. 
 * term_node relations are updated automatically (node with one of merging terms gets main term assigned)
 * after all opterions are done (adding of hierarchies, relations is optional) merging
 * terms get deleted
 *
 * @param $main_term
 *   id of term where other terms get merged into
 * @param $merging_terms
 *   array of term ids, which get merged into main term and afterwards deleted
 * @param $options
 *   array with additional options, possible values:
 *   'collect_parents': if true, all parents of merging terms get added to main term (only possible with multi hierarchies)
 *   'collect_children': if true, all children of merging terms get added to main term
 *   'collect_relations': if true, all relations of merging terms are transfered to main term
 */
function taxonomy_manager_merge($main_term, $merging_terms, $options = array()) {
  //TODO: add hook, so that other modules can consider changes
  foreach ($merging_terms as $merge_term) {
    
    //update node-relations
    $sql = db_query("SELECT nid FROM {term_node} WHERE tid = %d", $merge_term);
    while ($obj = db_fetch_object($sql)) {
      $nid = $obj->nid;
      db_query("DELETE FORM {term_node} WHERE tid = %d AND nid = %d", $merge_term, $nid);
      if (!db_result(db_query("SELECT COUNT(*) FORM {term_node} WHERE tid = %d AND nid = %d", $main_term, $nid))) {
        db_query("INSERT INTO {term_node} (tid, nid) (%d, %d)", $main_term, $nid);
      }
    }
    
    if ($options['collect_parents']) {
      $parents = taxonomy_get_parents($merge_term);
      foreach ($parents as $parent) {
        if (!db_result(db_query("SELECT COUNT(*) FROM {term_hierarchy} WHERE tid = %d AND parent = %d", $main_term, $parent))) {
           db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)", $main_term, $parent);
        }
      }
    }
    
    if ($options['collect_children']) {
      $children = taxonomy_get_children($merge_term);
      foreach ($children as $child) {
        if (!db_result(db_query("SELECT COUNT(*) FROM {term_hierarchy} WHERE tid = %d AND parent = %d", $child, $main_term))) {
           db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)", $child, $main_term);
        }
      }
    }
    
    if ($options['collect_relations']) {
      $relations = taxonomy_get_related($merge_term);
      foreach ($relations as $related_tid => $relation) {
        if ($relation->tid1 == $merge_term) {
          if (!db_result(db_query("SELECT COUNT(*) FROM {term_relation} WHERE tid1 = %d AND tid2 = %d", $main_term, $related_tid))) {
            db_query("INSERT INTO {term_relation} (tid1, tid2) VALUES (%d, %d)", $main_term, $related_tid);
          }
        }
        else if ($relation->tid2 == $merge_term) {
          if (!db_result(db_query("SELECT COUNT(*) FROM {term_relation} WHERE tid2 = %d AND tid1 = %d", $main_term, $related_tid))) {
            db_query("INSERT INTO {term_relation} (tid2, tid1) VALUES (%d, %d)", $main_term, $related_tid);
          }
        }
      }
    }
    
    //save merged term as synonym
    $term = taxonomy_get_term($merge_term);
    if (!db_result(db_query("SELECT COUNT(*) FROM {term_synonym} WHERE tid = %d AND name = '%s'", $main_term, $term->name))) {
      db_query("INSERT INTO {term_synonym} (tid, name) VALUES (%d, '%s')", $main_term, $term->name);
    }
    
    taxonomy_manager_delete_terms(array($merge_term));
  }
}

/**
 * helper function for getting out of term ids from autocomplete fields
 * non-exsiting terms get inserted autmatically
 * (part of taxonomy_node_save)
 *
 * @param $typed_input input string of form field
 * @param $vid vocabulary id
 * @return array of term ids
 */
function taxonomy_manager_autocomplete_tags_get_tids($typed_input, $vid) {
  $tids = array();
  
  $regexp = '%(?:^|,\ *)("(?>[^"]*)(?>""[^"]* )*"|(?: [^",]*))%x';
  preg_match_all($regexp, $typed_input, $matches);
  $typed_terms = array_unique($matches[1]);

  foreach ($typed_terms as $typed_term) {
    $typed_term = str_replace('""', '"', preg_replace('/^"(.*)"$/', '\1', $typed_term));
    $typed_term = trim($typed_term);
    if ($typed_term == "") { continue; }

    $possibilities = taxonomy_get_term_by_name($typed_term);
    $typed_term_tid = NULL; // tid match if any.
    foreach ($possibilities as $possibility) {
      if ($possibility->vid == $vid) {
        $typed_term_tid = $possibility->tid;
        $tids[] = $typed_term_tid;
      }
    }

    if (!$typed_term_tid) {
      $edit = array('vid' => $vid, 'name' => $typed_term);
      $status = taxonomy_save_term($edit);
      $typed_term_tid = $edit['tid'];
      $tids[] = $typed_term_tid;
    }
  }
  return $tids;
}


/**
 * recursive theme function to create a nested list of terms
 *
 * @param $element current element (part of form array) in recursion
 * @param $form whole form tree
 */
function theme_taxonomy_manager_elements($element) {
  $output .= "<ul>";
  
  if (is_array($element)) {  
    foreach (element_children($element) as $tid) {
      if (is_numeric($tid)) {
        $output .= '<li'. drupal_attributes($element[$tid]['#attributes']) .'>';
        $output .='<div class="term-line">';
        $output .='<div class="term-item">';
        $output .= drupal_render($element[$tid]['checkbox']);
        $output .= '</div>';
        $output .= '<div class="term-weight">';
        $output .= drupal_render($element[$tid]['weight']);
        $output .= '</div>';
        $output .= '<div class="clear"> </div></div>';
        
        if (is_array($element[$tid]['children'])) {
          $output .= theme('taxonomy_manager_elements', $element[$tid]['children']);
        }
        
        $output .='</li>';
      }
    } 
  }
  
  $output .= "</ul>";
  
  return $output;
}

/**
 * themes a real button form type (no form submit)
 */
function theme_no_submit_button($element) {
  // Make sure not to overwrite classes.
  if (isset($element['#attributes']['class'])) {
    $element['#attributes']['class'] = 'form-'. $element['#button_type'] .' '. $element['#attributes']['class'];
  }
  else {
    $element['#attributes']['class'] = 'form-'. $element['#button_type'];
  }

  return '<input type="button" '. (empty($element['#name']) ? '' : 'name="'. $element['#name'] .'" ')  .'id="'. $element['#id'].'" value="'. check_plain($element['#value']) .'" '. drupal_attributes($element['#attributes']) ." />\n";
}

